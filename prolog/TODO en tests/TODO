execute_command: %eventueel instance v vaguecommand doorvoeren

veel meer common sense, over wat robot kan

%%TODO 
%%constraint programming
%%definieer per actie en predicaat welke objecten er aan mogen meedoen
%%pickuptask heeft bij Object altijd een verplaatsbaar object (dit is een aparte klasse)
%TODO  movedsometging: O2 backtrackt over alles, ook tafels enzo
%%TODO empty ergens in boom zetten
%%%%%%%%%%%%%%%%%%%%%%%%%%%

enkel containers kunnen content hebben

%TODO is impliciet atm
%holdingobject(pr2robot1,O) ~ finite([1:false]) := true.

%%TODO holds_content(O,C) ~ finite([1:true]) :=
%%		generate_content_name(O,C).

%zet near op 10 cm voorlopig
%TODO vrij simpele benadering nog (D=10)
%TODO wat met symmetr?
/*
near(C1,O2,T)~ finite([1:true]) :=
	holds_content(O1,C1) ~=true,
	writeln(u: C1),
	writeln(O2),
	writeln(O1),	
	near(O1,O2,T)~=true.
near(O1,C2,T)~ finite([1:true]) :=
	holds_content(O2,C2) ~=true,	
	near(O1,O2,T)~=true.
*/

/*
has_position(O, T2) ~ finite([1:(X,Y,Z)]) := 
	%writeln(pos3),		
	T2 > 0,
	T1 is T2-1,
	get_action(T1,A),
	perform(A,T1),
	acts_on_object(A)~=O,
	has_effect(A,O,T1) ~= nothing,
	has_position(O,T1) ~= (X,Y,Z).
*/

%TODO loopgevaar bij has_goallocation

tafel
%voorlopig linkervoorste hoek kubus omhullende
%negeer Z even
%TODO gauss er bij

%on(object1,table1).
%TODO position en on van content moet ook anders
%TODO niet on als op rand

%TODO timestep bij dcpf nakijken

%commentaar: mooi voorbeeldvan volgorde, deze predicate deals met de overige cases van has_position	
laatste has_position

/*
can_pickup(Performer,Object) :-
	pickupable(ObjectClass),
	instance2(Object,O).

near(O1,O2,T)~ finite([1:true]) := 
	ground(O1),
	ground(O2),
	ground(T),

*/
	near(O2,O1,T)~=true.

%%%TODO
/*
acts_on_object(pickup_ca, moveablethings_ca).
domain(O,moveablethings_ca) ~ finite([1:true]) :- acts_on_object(_,O) ~= true. 
has_category(O) ~= finite([1:Sub]) := has_performer(A,Perf) ~= B, is_subcategory(Sub,actionperformers_ca), writeln(Sub).
*/
%waar controle op type actie en parameters?
/*
has_action_parameter(A,P) ~ finite([1:B]) := has_performer(A,P) ~= B.
has_action_parameter(A,O) ~ finite([1:B]) := acts_on_object(A,O) ~= B.
*/

%%%%TODO
%has_performer(p1)~ finite([0.9:pr2robot1,0.1:human1]) := true.
%distributionalclause(has_performer(p1), finite([0.9:pr2robot1,0.1:human1]), true, 1)
%distributionalclause:eval_query_backward_exp([distributionalclause(has_category(p1), finite([1:pickup_ca]), true, 1)],[],has_performer(p1)~=pr2robot1,1000,Prob,_,_).

sample_position_near(O,X1,Y1,Z1) :-
	init,
	timepoint(T),
	distributionalclause:eval_query_backward_distrib([],[],(X,Y,Z),(tableposnearobjontable(table1,O,T)~=(X,Y,Z)),10,Pc),
	writeln(Pc),
	Pc = [_:(X1,Y1,Z1)|_],
	writeln(sampled_x:X1),
	writeln(sampled_y:Y1),
	writeln(sampled_z:Z1).	

%TODO pickup
/*
has_category(A) ~ finite([1:pickup_ca]) :=
		perform(A,T),
		acts_on_object(A)~=O,		
		has_position(O,T)~=(X1,Y1,Z1),
		T2 is T+1,	
		has_position(O,T2)~=(X2,Y2,Z2),
		X1 = X2,
		Y1 = Y2,
		Zr is Z1+30,		
		Z2 = Zr.
*/

/*
has_category(A) ~ finite([1:pickandplace_ca]) :=
		
		perform(A,T),
		acts_on_object(A)~=O,	
		writeln(A),	
		has_position(O,T)~=(X1,Y1,Z1),
		T2 is T+1,	
		has_position(O,T2)~=(X2,Y2,Z2),	
		distance((X1,Y1,Z1),(X2,Y2,Z2))~=D,
		D >0.
*/


/*TODO loop
acts_on_object(A) ~ finite([O]) :=
	actioncategory(A)~=pickandplace_ca,
	writeln(test),
	movedsomething(O,T)~=true.		
*/

/*
pickupobjects(A) ~ uniform(Objs) :=
			get_instances(moveablethings_ca,Objs),
			writeln(testsssss: Objs).
*/
