eval_query_particle3(X,Q,N,P) :-
	Q=Query,
	get_max_priority(MaxP),
	bb_get(offset,Offset),
	writeln(Offset),
	bb_put(succeeding_sample_sum,[]),
	bb_put(sample_sum,0.0),
	length(FinalL,N),
	(
		between(1,N,Pos),
		I is Offset+Pos,
		abolish_all_tables,
		bb_get(I,LogWeight),
		Weight is exp(LogWeight),
		Weight>0,
		bb_get(sample_sum,OldTOT),
		NewTOT is OldTOT+Weight,
		bb_put(sample_sum,NewTOT),
		(
			(
				get_magic(true) ->
				(
					writeln(test1),
					init_query(I,Query),
					generate_sample_particlefilter(I,MaxP)
				)
				;
				true
			),
			(
				user:raoblackwellisation(true) ->
				(
					writeln(test2),
					findall(WW,query_proof_rao(I,Query,WW),ListWW),
					sum_list(ListWW,SumWW),
					(
						SumWW>0 ->
						(
							bb_get(succeeding_sample_sum,Old),
							New is Old+SumWW*Weight,% TO CHECK recently modified
							bb_put(succeeding_sample_sum,New)
						)
						;
						true
					)
				)
				;
				(
					get_magic(backward) ->
					(
						eraseall(tempparticle),
						findall(1:X,(distributionalclause:proof_query_backward(I,tempparticle,Query)),List)
						->
						(
							writeln(test:List),
							I2 is I-Offset,	
							assert(part(I2,List)),
							
							bb_get(succeeding_sample_sum,Old),
							sum_distrib(finite(Old),finite(List),Weight,finite(New)),
							bb_put(succeeding_sample_sum,New)
						)
						;
					  	true
					)
					;
					( 
						findall(1:X,query_proof(I,Query),List)
						->
						(
							bb_get(succeeding_sample_sum,Old),
							sum_distrib(finite(Old),finite(List),Weight,finite(New)),
							bb_put(succeeding_sample_sum,New)
						)
						;
					  	true
				  	)
			  	)
			)
		),
		fail;
		true
	),
	bb_delete(succeeding_sample_sum,SUCC),
	bb_delete(sample_sum,TOT),
	(
		SUCC==[] ->
		P=[]
		;
		divideby(SUCC,TOT,P)
	),
	findall((I2,List),part(I2,List),List2),
	writeln(List2),
	!.

step_particle3 :-
	findall((I2,List),part(I2,List),List2),
	writeln(List2),
	length(List2,N),
	step_particle3([],[],[],N,1.0,List2),
	resampling(N),
	writeln(okokokokok).

step_particle3(Actions,PosEvidence,Constraints,N,Delta,List2) :-
	%statistics(cputime,[TimeInit,_]),
	retractall(user:deltaT(_)),
	assert(user:deltaT(Delta)),
	bb_get(offset,Offset),
	writeln(offset2:Offset),
	bb_put(likelihood,0.0),
	get_max_priority(MaxP),
	user:timestep(Prec),
	retractall(user:timestep(_)),
	T is Prec+1,
	assert(user:timestep(T)),
	%write('timestep '),write(T),nl,
	bb_put(sample_sum,0.0),
	(
		between(1,N,Pos),
		I is Offset+Pos,
		abolish_all_tables,
		
		nth1(Pos,List2,Elem),
		Elem = (II,LL),
		nl,
		writeln(II),
		writeln(LL),
		length(LL,LengthLL),
		writeln(LengthLL),
			
		assert_list(I,Actions), % assert Actions
	
		(  LengthLL == 0 ->
			writeln(testets),
			PosEvidence2 = [exists ~= false],
			writeln(PosEvidence2),
			assert_list(I,PosEvidence2) % assert observations
		;
			PosEvidence2 = [exists ~= true],
			writeln(PosEvidence2),
			assert_list(I,PosEvidence2)
		),
		
		
		%(TO CHECK!! recently changed)
		
		bb_get(I,LogTempWeight),
		TempWeight is exp(LogTempWeight),
		TempWeight>0.0,
		bb_get(initdcpf,InitDCPF),
		(
			get_magic(true) ->
			(
				init_query(I,next(_)),
				init_query(I,next(_) ~= _),
				init_query_list(I,PosEvidence2)
			)
			;
			true %init_query_list(I,PosEvidence) % add callmagic for weight
		),
		
		(
			get_magic(backward) ->
			(
				user:raoblackwellisation(false) ->
				(	% Evaluate weight
					logweight_constraints(10,I,PosEvidence2,Constraints,P)
					%eval_weight_backward(I,PosEvidence,P)%,
					%write('weight '),write(P),nl
				)
				;
					true
			)
			;
			true
		),
		(
			(InitDCPF==false) ->
			(
				get_magic(backward) ->
					inferencestep_particlefilter_backward3(I)
				;
					generate_sample_particlefilter(I,MaxP)
			)
			;
			true
		),
		%dcpf:bb_get(offset,Offset),I is Offset+1,findall(A,(recorded(I,A,_),write(A),nl),_),trace,
		(
			user:raoblackwellisation(true) ->
			(
				% NEW
				add_rao_backward(I,PosEvidence2),
				inferencestep_particlefilter_magicoff_rao(I,_),
				%generate_sample_particlefilter(I,MaxP)
				(
					get_magic(backward) ->
						inferencestep_particlefilter_backward2(I)
					;
						generate_sample_particlefilter(I,MaxP)
				)
			)
			;
				true
		),
		
		(
			get_magic(true) ->
				eval_weight(I,PosEvidence2,P)
			;
			(
				user:raoblackwellisation(true) ->
				(
					nl,nl,write('particle '),write(I),nl,

					%findall(AA,(recorded(I,AA,_),write(AA),nl),_),
					findall(Sum,
						(
							recorded(I,next(VarRao) ~= finite(Distr),R),
							user:rao(VarRao),
							
							write(next(VarRao) ~= finite(Distr)),nl,
							findall(NewP:ValRao,(
										member(Pval:ValRao,Distr),
										
										eval_weightRao(I,PosEvidence2,WRao,VarRao,ValRao),
										write(eval_weightR(I,PosEvidence2,WRao,VarRao,ValRao)),nl,
										write('Val '),write(ValRao),write(' W '),write(WRao),nl,
										NewP is Pval*WRao
									    ),NewDistr),
							nl,
							findall(AA,(recorded(I,AA,_),write(AA),nl),_),
							nl,
							write('NewDistr '),write(NewDistr),nl,
							sum_prob(NewDistr,Sum),
							divideby(NewDistr,Sum,DistrNorm),
							write('W '),write(Sum),nl,
							write('DistrNorm '),write(DistrNorm),nl,
							erase(R),
							cleanDistribution(DistrNorm,Cleaned,0.0),
							recorda(I,next(VarRao) ~= finite(Cleaned),_)
						),ListSum),
					write('ListSum '),write(ListSum),nl,				
					product_list(ListSum,P1),
					write('------------------'),
%					P=Sum
					% for kalman filter  to complete!!!!!!!
					bb_put(pkalman,1.0),
					(% evaluation of clauses next() for rao variables with a gaussian distribution: gaussian(...)
						% mean_Xt,cov_Xt,A,B,mean_sistem_uncertainty,cov_sistem_uncertainty,H,mean_measurement_uncertainty,cov_measurement_uncertainty,input,measurement,post mean,post cov
						user:rao(VarRao),
						user:distributionalclause(next(VarRao),kalman(A,B,Input,MeanSys,CovSys,H,MeanMeas,CovMeas),Body,_),
						%trace,
						proof_query_backward(I,Body), %query_proof_rao(Key,Body,Weight), % evaluated for every value that satisfy the body (backtracking)
						ground(VarRao),
						ground(kalman(A,B,Input,MeanSys,CovSys,H,MeanMeas,CovMeas)),
						
						%write((next(VarRao),kalman(A,B,Input,MeanSys,CovSys,H,MeanMeas,CovMeas),Body,_)),nl,
						recorded(I,current(VarRao) ~= gaussian(M,Cov),_),
						% if not recorded find the prior:
						% TO DO!!
						%
						(
							member(observation(VarRao)~=Vevidence,PosEvidence2) ->
							true
							;
							(Vevidence=[])
						),
						write(kalmanrao(M,Cov,A,B,MeanSys,CovSys,H,MeanMeas,CovMeas,Input,Vevidence,Mpost,CovPost,Wkalman)),nl,
						
						kalmanrao(M,Cov,A,B,MeanSys,CovSys,H,MeanMeas,CovMeas,Input,Vevidence,Mpost,CovPost,Wkalman),
						recorda(I,next(VarRao) ~= gaussian(Mpost,CovPost),_),
						
						bb_get(pkalman,PKalman),
						NewPKalman is PKalman*Wkalman,
						bb_put(pkalman,NewPKalman),
						write('Wkalman '),write(Wkalman),nl,
						fail;
						true
					
					),% For new variables: evaluation of clauses next() for rao variables with a gaussian distribution: gaussian(...) 
					(
						% mean_Xt,cov_Xt,A,B,mean_sistem_uncertainty,cov_sistem_uncertainty,H,mean_measurement_uncertainty,cov_measurement_uncertainty,input,measurement,post mean,post cov
						user:rao(VarRao),
						user:distributionalclause(next(VarRao),gaussian(M,Cov),Body,_),
						%trace,
						proof_query_backward(I,Body), %query_proof_rao(Key,Body,Weight), % evaluated for every value that satisfy the body (backtracking)
						ground(VarRao),
						ground(gaussian(M,Cov)),
						recorda(I,next(VarRao) ~= gaussian(M,Cov),_),
						%write((next(VarRao),kalman(A,B,Input,MeanSys,CovSys,H,MeanMeas,CovMeas),Body,_)),nl,
						%recorded(I,current(VarRao) ~= gaussian(M,Cov),_),
						% if not recorded find the prior:
						% TO DO!!
						%
						member(observation(VarRao)~=Vevidence,PosEvidence2),
						
						%write(kalmanrao(M,Cov,A,B,MeanSys,CovSys,H,MeanMeas,CovMeas,Input,Vevidence,Mpost,CovPost,Wkalman)),nl,
						
						%kalmanrao(M,Cov,A,B,MeanSys,CovSys,H,MeanMeas,CovMeas,Input,Vevidence,Mpost,CovPost,Wkalman),
						
						densityGaussian(M,Cov,Vevidence,Wkalman),
						bb_get(pkalman,PKalman),
						NewPKalman is PKalman*Wkalman,
						bb_put(pkalman,NewPKalman),
						write('Wkalman '),write(Wkalman),nl,
						fail;
						true
					
					),
					bb_delete(pkalman,PtotKalman),
					P is P1*PtotKalman
				)
				;
				(		
					get_magic(false) ->
					(
						eval_weight_magicoff(I,PosEvidence2,P)
					)
					;
					true %	get_magic(backward)
					
				)
			)
		),
		%write('weight '),write(P),nl,
		bb_get(I,OldWeight),
		NewW is OldWeight+P, % log
		bb_put(I,NewW),
		
		bb_get(likelihood,Likelihood),
		NewLikelihood is Likelihood+exp(NewW),
		bb_put(likelihood,NewLikelihood),
		%writeln(('Likelihood ',Likelihood,' NewW ',NewW,' NewLikelihood',NewLikelihood)),
		%bb_put(I,P),
		%write('Oldweight '),write(OldWeight),write(' weight '),write(NewW),nl,
		fail;
		true
	),
	bb_get(likelihood,TotLikelihood),
	bb_get(loglikelihood,LogLikelihood),
	NewLogLikelihood is LogLikelihood+log(TotLikelihood/N),
	bb_put(loglikelihood,NewLogLikelihood),
	%writeln(('TotLikelihood',TotLikelihood,' LogLikelihood ',LogLikelihood,'  NewLogLikelihood ',NewLogLikelihood)),
	(
		user:lifted(true) -> % lifted part
		(
			(distributionalclause:proof_query_backward_lifted(global,next(A)),fail;true),
			distributionalclause:current2next(global)
		)
		;
		true
	),
	bb_put(initdcpf,false).
	%statistics(cputime,[TimeEnd1,_]),
	%Tempo1 is (TimeEnd1-TimeInit)/1000.0,
	%write('before resampling '),write(Tempo1),nl,
	%printp(1),
	%resampling(N).%,
	%statistics(cputime,[TimeEnd2,_]),
	%Tempo2 is (TimeEnd2-TimeInit)/1000.0,
	%write(Tempo2),nl.
