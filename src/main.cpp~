#include <iostream>
#include <ros/ros.h>

#include <actionlib/client/simple_action_client.h>
#include <tabletop_object_detector/TabletopDetection.h>
#include <tabletop_collision_map_processing/TabletopCollisionMapProcessing.h>
#include <object_manipulation_msgs/PickupAction.h>
#include <object_manipulation_msgs/PlaceAction.h>
#include <tf/tf.h>
#include <limits>
#include <json_prolog/prolog.h>
#include <household_objects_database_msgs/GetModelDescription.h>
#include <std_msgs/String.h>
#include <arm_navigation_msgs/MoveArmAction.h>
#include <arm_navigation_msgs/utils.h>

#include <btBulletCollisionCommon.h>

#include <limits>
#include <json_prolog/prolog.h>


#include <kinematics_msgs/GetPositionFK.h>

#include <ros/ros.h>
#include <actionlib/client/simple_action_client.h>

#include <kinematics_msgs/GetKinematicSolverInfo.h>
#include <kinematics_msgs/GetPositionFK.h>

#include <object_manipulator/tools/mechanism_interface.h>
#include <object_manipulator/tools/hand_description.h>
#include <object_manipulator/tools/service_action_wrappers.h>
#include <object_manipulator/tools/ik_tester_fast.h>

#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include <manipulation_msgs/Grasp.h>
#include <object_manipulation_msgs/ClusterBoundingBox.h>
#include <object_manipulation_msgs/tools.h>

#include <object_manipulator/tools/vector_tools.h>
#include <object_manipulator/tools/arm_configurations.h>
#include <sensor_msgs/point_cloud_conversion.h>
//#include <pr2_interactive_manipulation/interactive_manipulation_backend.h>

#define ARRAY_SIZE(array) (sizeof((array))/sizeof((array[0])))

#include <pr2_controllers_msgs/PointHeadAction.h>

#include <geometry_msgs/Quaternion.h>

using object_manipulation_msgs::ManipulationResult;
using object_manipulator::InterruptRequestedException;

//#include <pr2_object_manipulation_msgs/IMGUIAction.h>

// Our Action interface type, provided as a typedef for convenience
typedef actionlib::SimpleActionClient<pr2_controllers_msgs::PointHeadAction> PointHeadClient;
using namespace std;
using namespace json_prolog;

class RobotHead
{
private:
  PointHeadClient* point_head_client_;

public:
  //! Action client initialization 
  RobotHead()
  {
    //Initialize the client for the Action interface to the head controller
    point_head_client_ = new PointHeadClient("/head_traj_controller/point_head_action", true);

    //wait for head controller action server to come up 
    while(!point_head_client_->waitForServer(ros::Duration(5.0))){
      ROS_INFO("Waiting for the point_head_action server to come up");
    }
  }

  ~RobotHead()
  {
    delete point_head_client_;
  }

  //! Points the high-def camera frame at a point in a given frame  
  void lookAt(std::string frame_id, double x, double y, double z)
  {
    //the goal message we will be sending
    pr2_controllers_msgs::PointHeadGoal goal;

    //the target point, expressed in the requested frame
    geometry_msgs::PointStamped point;
    point.header.frame_id = frame_id;
    point.point.x = x; point.point.y = y; point.point.z = z;
    goal.target = point;

    //we are pointing the high-def camera frame 
    //(pointing_axis defaults to X-axis)
    goal.pointing_frame = "high_def_frame";

    //take at least 0.5 seconds to get there
    goal.min_duration = ros::Duration(0.5);

    //and go no faster than 1 rad/s
    goal.max_velocity = 1.0;

    //send the goal
    point_head_client_->sendGoal(goal);

    //wait for it to get there (abort after 2 secs to prevent getting stuck)
    point_head_client_->waitForResult(ros::Duration(2));
  }

  //! Shake the head from left to right n times  
  void shakeHead(int n)
  {
    int count = 0;
    while (ros::ok() && ++count <= n )
    {
      //Looks at a point forward (x=5m), slightly left (y=1m), and 1.2m up
      lookAt("base_link", 5.0, 1.0, 1.2);

      //Looks at a point forward (x=5m), slightly right (y=-1m), and 1.2m up
      lookAt("base_link", 5.0, -1.0, 1.2);
    }
  }

  void lookdown()
  {
		lookAt("base_link", 1.0, 0, 0);
	
  }

  tabletop_collision_map_processing::TabletopCollisionMapProcessing scanTable(ros::NodeHandle nh,ros::ServiceClient collision_processing_srv,ros::ServiceClient object_detection_srv)
  {


	    ROS_INFO("Calling tabletop detector");
	    tabletop_object_detector::TabletopDetection detection_call;
	    detection_call.request.return_clusters = true;
	    detection_call.request.return_models = true;
	    detection_call.request.num_models = 1;
	    if (!object_detection_srv.call(detection_call))
	    {
	      ROS_ERROR("Tabletop detection service failed");
	    }
	    if (detection_call.response.detection.result !=
	        detection_call.response.detection.SUCCESS)
	    {
	      ROS_ERROR("Tabletop detection returned error code %d",
	                detection_call.response.detection.result);
	    }
	    if (detection_call.response.detection.clusters.empty() &&
	        detection_call.response.detection.models.empty() )
	    {
	      ROS_ERROR("The tabletop detector detected the table, "
	                "but found no objects");
	    }

	      ROS_INFO("Calling collision map processing");
	      tabletop_collision_map_processing::TabletopCollisionMapProcessing
	        processing_call;
	      processing_call.request.detection_result =
	        detection_call.response.detection;
	      processing_call.request.reset_collision_models = true;
	      processing_call.request.reset_attached_models = true;
	      processing_call.request.desired_frame = "base_link";
	      if (!collision_processing_srv.call(processing_call))
	      {
	        ROS_ERROR("Collision map processing service failed");
	      }
	      //the collision map processor returns instances of graspable objects
	      if (processing_call.response.graspable_objects.empty())
	      {
	        ROS_ERROR("Collision map processing returned no graspable objects");
	      }
	      return processing_call;
  }

};

class LeftArm
{
private:


public:
	bool toSide;
	tf::Quaternion gripper_orientation;
	tf::Vector3 pickup_location;
	manipulation_msgs::Grasp pickupGrasp;

	LeftArm()
  {
		toSide = false;

		tfScalar x = 0;
		gripper_orientation.setX(x);
		tfScalar y = 0;
		gripper_orientation.setY(y);
		tfScalar z = 0;
		gripper_orientation.setZ(z);
	    tfScalar w = 1;
		gripper_orientation.setW(w);
		gripper_orientation.normalize();
  }

  ~LeftArm()
  {
    //delete move_arm_client;
  }

//  desired_pose.pose.position.x = 0.2;
//  	  	  desired_pose.pose.position.y = 0.7;
//  	  	  desired_pose.pose.position.z = 0.2;

  void setPickupLocation(geometry_msgs::PoseStamped start_pose){
	  tfScalar x = start_pose.pose.position.x;
	  tfScalar y = start_pose.pose.position.y;
	  tfScalar z = start_pose.pose.position.z;
	  pickup_location.setX(x);
	  pickup_location.setY(y);
	  pickup_location.setZ(z);
  }

  void setOrientation(geometry_msgs::PoseStamped start_pose){
	  					  	  tfScalar x = start_pose.pose.orientation.x;
	  					  	  gripper_orientation.setX(x);
	  					  	  tfScalar y = start_pose.pose.orientation.y;
	  					  	  gripper_orientation.setY(y);
	  					  	  tfScalar z = start_pose.pose.orientation.z;
	  					  	  gripper_orientation.setZ(z);
	  					  	  tfScalar w = start_pose.pose.orientation.w;
	  					  	  gripper_orientation.setW(w);
	  					  	  gripper_orientation.normalize();

	  					  	  std::cout << gripper_orientation.getX() << std::endl;
	  					  	  std::cout << gripper_orientation.getY() << std::endl;
	  					  	  std::cout << gripper_orientation.getZ() << std::endl;
	  					  	  std::cout << gripper_orientation.getW() << std::endl;

	  					  	double x2 = gripper_orientation.getX();
	  					  	double y2 = gripper_orientation.getY();
	  					  	double z2 = gripper_orientation.getZ();
	  					  	double w2 = gripper_orientation.getW();

	  					  	double magnitude2 = sqrt(pow(x2,2.0) + pow(y2,2.0) + pow(z2,2.0) + pow(w2,2.0));
	  				        std::cout << magnitude2 << std::endl;
  }

  void moveSide(ros::NodeHandle nh,double x,double y,double z,double w)
  {

	  //TODO waitforservice
	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
	  arm_navigation_msgs::GetRobotState::Request req;
	  arm_navigation_msgs::GetRobotState::Response res;

	  get_state_client_.call(req,res);

	  int njoints = res.robot_state.joint_state.name.size();
	  //std::cout << "Number of joints found: " << njoints;
	  for (int i = 0 ; i < njoints ; i++) {
		  	//std::cout << i;
	  		//std::cout << res.robot_state.joint_state.name[i] << std::endl;
	  }

	  int njoints2 = res.robot_state.multi_dof_joint_state.joint_names.size();
	  for (int i = 0 ; i < njoints2 ; i++) {
	  	  //std::cout << res.robot_state.multi_dof_joint_state.joint_names[i] << std::endl;
	  }

	  //std::cout << res.robot_state.joint_state.header.frame_id << std::endl ;
	  //std::cout << res.robot_state.joint_state.name[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.effort[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.position[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.velocity[28] << std::endl;

	  actionlib::SimpleActionClient<arm_navigation_msgs::MoveArmAction> move_arm2("move_left_arm",true);
	  move_arm2.waitForServer(ros::Duration(15.0));

	  arm_navigation_msgs::MoveArmGoal goal;

	  	  goal.motion_plan_request.group_name = "left_arm";
	  	  goal.motion_plan_request.num_planning_attempts = 1;
	  	  goal.motion_plan_request.planner_id = std::string("");
	  	  goal.planner_service_name = std::string("ompl_planning/plan_kinematic_path");
	  	  goal.motion_plan_request.allowed_planning_time = ros::Duration(15.0);

	  	  arm_navigation_msgs::SimplePoseConstraint desired_pose;
	  	  desired_pose.header.frame_id = "base_link";//torso_lift_link
	  	  desired_pose.link_name = "l_wrist_roll_link";//l_wrist_roll_link
	  	  desired_pose.pose.position.x = 0.25;
	  	  desired_pose.pose.position.y = 0.8;
	  	  desired_pose.pose.position.z = 1.0;

	  	  desired_pose.pose.orientation.x = x;
	  	  desired_pose.pose.orientation.y = y;
	  	  desired_pose.pose.orientation.z = z;
	  	  desired_pose.pose.orientation.w = w;

	  	  desired_pose.absolute_position_tolerance.x = 0.05;
	  	  desired_pose.absolute_position_tolerance.y = 0.05;
	  	  desired_pose.absolute_position_tolerance.z = 0.20;

	  	  desired_pose.absolute_roll_tolerance = 0.30;
	  	  desired_pose.absolute_pitch_tolerance = 0.30;
	  	  desired_pose.absolute_yaw_tolerance = 0.30;

	  	  arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);

	  	  if (nh.ok())
	  	  {
	  	    bool finished_within_time2 = false;
	  	    move_arm2.sendGoal(goal);
	  	    finished_within_time2 = move_arm2.waitForResult(ros::Duration(20.0));
	  	    if (!finished_within_time2)
	  	    {
	  	    	move_arm2.cancelGoal();
	  	      ROS_INFO("Failed ideal pose, trying standard.");

	  	    desired_pose.pose.orientation.x = x;
	  	    	  	  desired_pose.pose.orientation.y = y;
	  	    	  	  desired_pose.pose.orientation.z = z;
	  	    	  	  desired_pose.pose.orientation.w = w;
	  	    	  	arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);//TODO
	  	    	  move_arm2.sendGoal(goal);
	  	    	move_arm2.waitForResult(ros::Duration(20.0));
	  	    }
	  	    else
	  	    {
	  	      actionlib::SimpleClientGoalState state2 = move_arm2.getState();
	  	      bool success2 = (state2 == actionlib::SimpleClientGoalState::SUCCEEDED);
	  	      if(success2)
	  	        ROS_INFO("Action finished: %s",state2.toString().c_str());
	  	      else
	  	        ROS_INFO("Action failed: %s",state2.toString().c_str());
	  	    }
	  	  }
	  	  toSide = true;
  }

  void moveSide(ros::NodeHandle nh)
    {
	  double x2 = gripper_orientation.getX();
	  double y2 = gripper_orientation.getY();
	  double z2 = gripper_orientation.getZ();
	  double w2 = gripper_orientation.getW();
	  cout << x2 << endl;
	  cout << y2 << endl;
	  cout << z2 << endl;
	  cout << w2 << endl;
	  moveSide(nh,x2,y2,z2,w2);
    }

  void moveSideStandard(ros::NodeHandle nh)
  {
  	  moveSide(nh,0,0,0,1);
  }

  void moveToLocation(ros::NodeHandle nh,double x, double y, double z)
  {
	  double x2 = gripper_orientation.getX();
	  cout << x2 << endl;
	  double y2 = gripper_orientation.getY();
	  cout << y2 << endl;
	  double z2 = gripper_orientation.getZ();
	  cout << z2 << endl;
	  double w2 = gripper_orientation.getW();
	  cout << w2 << endl;
	  moveToLocation(nh,x,y,z,x2,y2,z2,w2);
  }

  void moveToLocation(ros::NodeHandle nh,double x, double y, double z,double x2, double y2, double z2,double w2)
    {
/*
  	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
  	  arm_navigation_msgs::GetRobotState::Request req;
  	  arm_navigation_msgs::GetRobotState::Response res;

  	  get_state_client_.call(req,res);
*/

  	  actionlib::SimpleActionClient<arm_navigation_msgs::MoveArmAction> move_arm2("move_left_arm",true);
  	  move_arm2.waitForServer(ros::Duration(15.0));
  	  //move_arm2.getState().toString()
  	  ROS_INFO("Connected to server");

  	  arm_navigation_msgs::MoveArmGoal goal;

  	  	  goal.motion_plan_request.group_name = "left_arm";
  	  	  goal.motion_plan_request.num_planning_attempts = 1;
  	  	  goal.motion_plan_request.planner_id = std::string("");
  	  	  goal.planner_service_name = std::string("ompl_planning/plan_kinematic_path");
  	  	  goal.motion_plan_request.allowed_planning_time = ros::Duration(15.0);

  	  	  arm_navigation_msgs::SimplePoseConstraint desired_pose;
  	  	  desired_pose.header.frame_id = "base_link";
  	  	  desired_pose.link_name = "l_wrist_roll_link";//l_wrist_roll_link
  	  	  desired_pose.pose.position.x = x;
  	  	  desired_pose.pose.position.y = y;
  	  	  desired_pose.pose.position.z = z+0.2;

  	  	desired_pose.pose.orientation.x = x2;
  	  	desired_pose.pose.orientation.y = y2;
  	  	desired_pose.pose.orientation.z = z2;
  	  	desired_pose.pose.orientation.w = w2; //start_pose.pose.orientation.w;

  	  	  desired_pose.absolute_position_tolerance.x = 0.05;
  	  	  desired_pose.absolute_position_tolerance.y = 0.05;
  	  	  desired_pose.absolute_position_tolerance.z = 0.01;

  	  	  desired_pose.absolute_roll_tolerance = 1;
  	  	  desired_pose.absolute_pitch_tolerance = 1;
  	  	  desired_pose.absolute_yaw_tolerance = 1;

  	  	  arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);

  	  	  if (nh.ok())
  	  	  {
  	  	    bool finished_within_time2 = false;
  	  	    //SimpleCli= move_arm2.getState();
  	  	    move_arm2.sendGoal(goal);
  	  	    finished_within_time2 = move_arm2.waitForResult(ros::Duration(15.0));
  	  	    if (!finished_within_time2)
  	  	    {
  	  	    	move_arm2.cancelGoal();
  	  	      ROS_INFO("Timed out achieving goal A");
  	  	    }
  	  	    else
  	  	    {
  	  	      actionlib::SimpleClientGoalState state2 = move_arm2.getState();
  	  	      bool success2 = (state2 == actionlib::SimpleClientGoalState::SUCCEEDED);
  	  	      if(success2)
  	  	        ROS_INFO("Action finished: %s",state2.toString().c_str());
  	  	      else
  	  	        ROS_INFO("Action failed: %s",state2.toString().c_str());
  	  	    }
  	  	  }
  	  	  toSide = true;
    }
  geometry_msgs::PoseStamped  getPosition(ros::NodeHandle nh,std::string frame){
	  geometry_msgs::PoseStamped pose;

  	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
  	      arm_navigation_msgs::GetRobotState::Request req;
  	      arm_navigation_msgs::GetRobotState::Response res;
  	      get_state_client_.call(req,res);


  	      ros::service::waitForService("pr2_left_arm_kinematics/get_fk");
  	      ros::ServiceClient fk_client = nh.serviceClient<kinematics_msgs::GetPositionFK>("pr2_left_arm_kinematics/get_fk");

  	      kinematics_msgs::GetPositionFK::Request  fk_request;
  	      kinematics_msgs::GetPositionFK::Response fk_response;

  	      fk_request.header.frame_id = frame;
  	      fk_request.fk_link_names.resize(1);
  	      fk_request.fk_link_names[0] = "l_wrist_roll_link";
  	      fk_request.robot_state = res.robot_state;
  	      if(fk_client.call(fk_request, fk_response))
  	      {
  	      			  std::cout << fk_response.fk_link_names[0] << std::endl;
  	      			std::cout << fk_response.pose_stamped[0].header.frame_id << std::endl;
  	      			  pose = fk_response.pose_stamped[0];
  	      			  printPose(pose);
  	      }
  	      else{
  	    	  std::cout << "can't get link info" << std::endl;
  	      }
  	      return pose;
    }

  void printPose(geometry_msgs::PoseStamped pose){
	  std::cout << "Wrist pose currently:" << std::endl;
	  std::cout << pose.pose.position.x << std::endl;
	  std::cout << pose.pose.position.y << std::endl;
	  std::cout << pose.pose.position.z << std::endl;
	  std::cout << pose.pose.orientation.x << std::endl;
	  std::cout << pose.pose.orientation.y << std::endl;
	  std::cout << pose.pose.orientation.z << std::endl;
	  std::cout << pose.pose.orientation.w << std::endl;
  }

  void place(tabletop_collision_map_processing::TabletopCollisionMapProcessing
  	        processing_call,int chosen,ros::NodeHandle nh,ros::ServiceClient collision_processing_srv,ros::ServiceClient object_detection_srv){


	   actionlib::SimpleActionClient<object_manipulation_msgs::PlaceAction>
	     place_client("/object_manipulator/object_manipulator_place", true);
	   while(!place_client.waitForServer(ros::Duration(2.0)) && nh.ok())
	     {
	       ROS_INFO_STREAM("Waiting for action client " << "/object_manipulator/object_manipulator_place");
	     }
	     if (!nh.ok()) exit(0);

	  geometry_msgs::PoseStamped place_location;
	  place_location.header.frame_id = processing_call.response.graspable_objects.at(0).reference_frame_id;
	  place_location.pose.orientation.w = 1;
	  place_location.header.stamp = ros::Time::now();
	  place_location.pose.position.x += 0.1;

	  ROS_INFO("Calling the place action");
	  object_manipulation_msgs::PlaceGoal place_goal;
	  place_goal.place_locations.push_back(place_location);
	  place_goal.collision_object_name = processing_call.response.collision_object_names.at(0);
	  place_goal.collision_support_surface_name = processing_call.response.collision_support_surface_name;

	    place_goal.grasp = pickupGrasp;
	    place_goal.arm_name = "left_arm";
	    place_goal.place_padding = 0.03;
	    place_goal.desired_retreat_distance = 0.1;
	    place_goal.min_retreat_distance = 0.05;

	    geometry_msgs::Vector3Stamped direction;
	    direction.header.stamp = ros::Time::now();
	    direction.header.frame_id = "base_link";
	    direction.vector.x = 0;
	    direction.vector.y = 0;
	    direction.vector.z = -1;
	    place_goal.approach.direction = direction;
	    place_goal.approach.desired_distance = 0.08;
	    place_goal.approach.min_distance = 0.06;
	    place_goal.use_reactive_place = false;
	    place_client.sendGoal(place_goal);

	    while (!place_client.waitForResult(ros::Duration(10.0)))
	    {
	      ROS_INFO("Waiting for the place action...");
	    }
	    object_manipulation_msgs::PlaceResult place_result =
	      *(place_client.getResult());
	    if (place_client.getState() !=
	        actionlib::SimpleClientGoalState::SUCCEEDED)
	    {
	      ROS_ERROR("Place failed with error code %d",
	                place_result.manipulation_result.value);
	    }
  }

  void pickup(tabletop_collision_map_processing::TabletopCollisionMapProcessing
	        processing_call,int chosen,ros::NodeHandle nh,ros::ServiceClient collision_processing_srv,ros::ServiceClient object_detection_srv){

	    actionlib::SimpleActionClient<object_manipulation_msgs::PickupAction>
	      pickup_client("/object_manipulator/object_manipulator_pickup", true);
	    while ( !ros::service::waitForService("/object_detection",ros::Duration(2.0)) && nh.ok() )
	    {
	      ROS_INFO("Waiting for object detection service to come up");
	    }
	    if (!nh.ok()) exit(0);
	    object_detection_srv =
	      nh.serviceClient<tabletop_object_detector::TabletopDetection>
	      ("/object_detection", true);

	    while ( !ros::service::waitForService("/tabletop_collision_map_processing/tabletop_collision_map_processing",
	                                          ros::Duration(2.0)) && nh.ok() )
	    {
	      ROS_INFO("Waiting for collision processing service to come up");
	    }
	    if (!nh.ok()) exit(0);
	    collision_processing_srv =
	      nh.serviceClient
	      <tabletop_collision_map_processing::TabletopCollisionMapProcessing>
	      ("/tabletop_collision_map_processing/tabletop_collision_map_processing", true);

	    while(!pickup_client.waitForServer(ros::Duration(2.0)) && nh.ok())
	    {
	      ROS_INFO_STREAM("Waiting for action client " << "/object_manipulator/object_manipulator_pickup");
	    }
	    if (!nh.ok()) exit(0);

	    ROS_INFO("Calling the pickup action");
	    object_manipulation_msgs::PickupGoal pickup_goal;
	    pickup_goal.target = processing_call.response.graspable_objects.at(chosen);
	    //pass the name that the object has in the collision environment
	    //this name was also returned by the collision map processor
	    pickup_goal.collision_object_name =
	      processing_call.response.collision_object_names.at(chosen);
	    pickup_goal.collision_support_surface_name =
	      processing_call.response.collision_support_surface_name;
	    pickup_goal.arm_name = "left_arm";
	    geometry_msgs::Vector3Stamped direction;
	    direction.header.stamp = ros::Time::now();
	    direction.header.frame_id = "base_link";
	    direction.vector.x = 0;
	    direction.vector.y = 0;
	    direction.vector.z = 1;
	    pickup_goal.lift.direction = direction;
	    pickup_goal.lift.desired_distance = 0.1;
	    pickup_goal.lift.min_distance = 0.05;
	    pickup_goal.use_reactive_lift = false;
	    pickup_goal.use_reactive_execution = false;
	    pickup_client.sendGoal(pickup_goal);
	    while (!pickup_client.waitForResult(ros::Duration(10.0)))
	    {
	      ROS_INFO("Waiting for the pickup action...");
	    }
	    object_manipulation_msgs::PickupResult pickup_result =
	      *(pickup_client.getResult());
	    if (pickup_client.getState() != actionlib::SimpleClientGoalState::SUCCEEDED)
	    {
	      ROS_ERROR("The pickup action has failed with result code %d",
	                pickup_result.manipulation_result.value);

	    }
	    pickupGrasp = pickup_result.grasp;
  }
};

class RightArm
{
private:


public:
	bool toSide;
	tf::Quaternion gripper_orientation;
	tf::Vector3 pickup_location;
	manipulation_msgs::Grasp pickupGrasp;

	RightArm()
  {
		toSide = false;

		tfScalar x = 0;
		gripper_orientation.setX(x);
		tfScalar y = 0;
		gripper_orientation.setY(y);
		tfScalar z = 0;
		gripper_orientation.setZ(z);
	    tfScalar w = 1;
		gripper_orientation.setW(w);
		gripper_orientation.normalize();
  }

  ~RightArm()
  {
    //delete move_arm_client;
  }

  void setPickupLocation(geometry_msgs::PoseStamped start_pose){
	  tfScalar x = start_pose.pose.position.x;
	  tfScalar y = start_pose.pose.position.y;
	  tfScalar z = start_pose.pose.position.z;
	  pickup_location.setX(x);
	  pickup_location.setY(y);
	  pickup_location.setZ(z);
  }

  void setOrientation(geometry_msgs::PoseStamped start_pose){
	  					  	  tfScalar x = start_pose.pose.orientation.x;
	  					  	  gripper_orientation.setX(x);
	  					  	  tfScalar y = start_pose.pose.orientation.y;
	  					  	  gripper_orientation.setY(y);
	  					  	  tfScalar z = start_pose.pose.orientation.z;
	  					  	  gripper_orientation.setZ(z);
	  					  	  tfScalar w = start_pose.pose.orientation.w;
	  					  	  gripper_orientation.setW(w);
	  					  	  gripper_orientation.normalize();

	  					  	  std::cout << gripper_orientation.getX() << std::endl;
	  					  	  std::cout << gripper_orientation.getY() << std::endl;
	  					  	  std::cout << gripper_orientation.getZ() << std::endl;
	  					  	  std::cout << gripper_orientation.getW() << std::endl;

	  					  	double x2 = gripper_orientation.getX();
	  					  	double y2 = gripper_orientation.getY();
	  					  	double z2 = gripper_orientation.getZ();
	  					  	double w2 = gripper_orientation.getW();

	  					  	double magnitude2 = sqrt(pow(x2,2.0) + pow(y2,2.0) + pow(z2,2.0) + pow(w2,2.0));
	  				        std::cout << magnitude2 << std::endl;
  }

  void moveSide(ros::NodeHandle nh,double x,double y,double z,double w)
  {

	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
	  	  arm_navigation_msgs::GetRobotState::Request req;
	  	  arm_navigation_msgs::GetRobotState::Response res;

	  	  get_state_client_.call(req,res);

	  	  int njoints = res.robot_state.joint_state.name.size();
	  	  std::cout << "Number of joints found: " << njoints;
	  	  for (int i = 0 ; i < njoints ; i++) {
	  		  //	std::cout << i;
	  	  	//	std::cout << res.robot_state.joint_state.name[i] << std::endl;
	  	  }


	  	  //std::cout << res.robot_state.joint_state.header;
	  	  //std::cout << res.robot_state.joint_state.name[43] << std::endl;
	  	  //std::cout << res.robot_state.joint_state.effort[43] << std::endl;
	  	  //std::cout << res.robot_state.joint_state.position[43] << std::endl;
	  	  //std::cout << res.robot_state.joint_state.velocity[43] << std::endl;

	  //std::cout << res.robot_state.joint_state.header.frame_id << std::endl ;
	  //std::cout << res.robot_state.joint_state.name[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.effort[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.position[28] << std::endl;
	  //std::cout << res.robot_state.joint_state.velocity[28] << std::endl;

	  actionlib::SimpleActionClient<arm_navigation_msgs::MoveArmAction> move_arm2("move_right_arm",true);
	  move_arm2.waitForServer(ros::Duration(15.0));

	  arm_navigation_msgs::MoveArmGoal goal;

	  	  goal.motion_plan_request.group_name = "right_arm";
	  	  goal.motion_plan_request.num_planning_attempts = 1;
	  	  goal.motion_plan_request.planner_id = std::string("");
	  	  goal.planner_service_name = std::string("ompl_planning/plan_kinematic_path");
	  	  goal.motion_plan_request.allowed_planning_time = ros::Duration(15.0);

	  	  arm_navigation_msgs::SimplePoseConstraint desired_pose;
	  	desired_pose.header.frame_id = "torso_lift_link";//TODO base_link
	  	desired_pose.link_name = "r_wrist_roll_link";
	  		    desired_pose.pose.position.x = 0.2;
	  		    desired_pose.pose.position.y = -0.7;
	  		    desired_pose.pose.position.z = 0.2;

	  		    desired_pose.pose.orientation.x = 0;
	  		    desired_pose.pose.orientation.y = 0;
	  		    desired_pose.pose.orientation.z = 0;
	  		    desired_pose.pose.orientation.w = 1;

	  		    desired_pose.absolute_position_tolerance.x = 0.10;
	  		    desired_pose.absolute_position_tolerance.y = 0.10;
	  		    desired_pose.absolute_position_tolerance.z = 0.10;

	  		    desired_pose.absolute_roll_tolerance = 0.20;
	  		    desired_pose.absolute_pitch_tolerance = 0.20;
	  		    desired_pose.absolute_yaw_tolerance = 0.20;

	  	  arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);

	  	  if (nh.ok())
	  	  {
	  	    bool finished_within_time2 = false;
	  	    move_arm2.sendGoal(goal);
	  	    finished_within_time2 = move_arm2.waitForResult(ros::Duration(20.0));
	  	    if (!finished_within_time2)
	  	    {
	  	    	move_arm2.cancelGoal();
	  	    	ROS_INFO("Failed ideal pose, trying standard.");

	  	    desired_pose.pose.orientation.x = x;
	  	    	  	  desired_pose.pose.orientation.y = y;
	  	    	  	  desired_pose.pose.orientation.z = z;
	  	    	  	  desired_pose.pose.orientation.w = w;
	  	    	  	arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);//TODO
	  	    	  move_arm2.sendGoal(goal);
	  	    	move_arm2.waitForResult(ros::Duration(20.0));
	  	    }
	  	    else
	  	    {
	  	      actionlib::SimpleClientGoalState state2 = move_arm2.getState();
	  	      bool success2 = (state2 == actionlib::SimpleClientGoalState::SUCCEEDED);
	  	      if(success2)
	  	        ROS_INFO("Action finished: %s",state2.toString().c_str());
	  	      else
	  	        ROS_INFO("Action failed: %s",state2.toString().c_str());
	  	    }
	  	  }
	  	  toSide = true;
  }

  void moveSide(ros::NodeHandle nh)
    {
	  double x2 = gripper_orientation.getX();
	  double y2 = gripper_orientation.getY();
	  double z2 = gripper_orientation.getZ();
	  double w2 = gripper_orientation.getW();
	  cout << x2 << endl;
	  cout << y2 << endl;
	  cout << z2 << endl;
	  cout << w2 << endl;
	  moveSide(nh,x2,y2,z2,w2);
    }

  void moveSideStandard(ros::NodeHandle nh)
  {
  	  moveSide(nh,0,0,0,1);
  }

  void moveToLocation(ros::NodeHandle nh,double x, double y, double z)
  {
	  double x2 = gripper_orientation.getX();
	  cout << x2 << endl;
	  double y2 = gripper_orientation.getY();
	  cout << y2 << endl;
	  double z2 = gripper_orientation.getZ();
	  cout << z2 << endl;
	  double w2 = gripper_orientation.getW();
	  cout << w2 << endl;
	  moveToLocation(nh,x,y,z,x2,y2,z2,w2);
  }

  void moveToLocation(ros::NodeHandle nh,double x, double y, double z,double x2, double y2, double z2,double w2)
    {
/*
  	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
  	  arm_navigation_msgs::GetRobotState::Request req;
  	  arm_navigation_msgs::GetRobotState::Response res;

  	  get_state_client_.call(req,res);
*/

  	  actionlib::SimpleActionClient<arm_navigation_msgs::MoveArmAction> move_arm2("move_right_arm",true);
  	  move_arm2.waitForServer(ros::Duration(15.0));
  	  //move_arm2.getState().toString()
  	  ROS_INFO("Connected to server");

  	  arm_navigation_msgs::MoveArmGoal goal;

  	  	  goal.motion_plan_request.group_name = "right_arm";
  	  	  goal.motion_plan_request.num_planning_attempts = 1;
  	  	  goal.motion_plan_request.planner_id = std::string("");
  	  	  goal.planner_service_name = std::string("ompl_planning/plan_kinematic_path");
  	  	  goal.motion_plan_request.allowed_planning_time = ros::Duration(15.0);

  	  	  arm_navigation_msgs::SimplePoseConstraint desired_pose;
  	  	  desired_pose.header.frame_id = "base_link";
  	  	  desired_pose.link_name = "r_wrist_roll_link";//l_wrist_roll_link
  	  	  desired_pose.pose.position.x = x;
  	  	  desired_pose.pose.position.y = y;
  	  	  desired_pose.pose.position.z = z+0.2;

  	  	desired_pose.pose.orientation.x = x2;
  	  	desired_pose.pose.orientation.y = y2;
  	  	desired_pose.pose.orientation.z = z2;
  	  	desired_pose.pose.orientation.w = w2; //start_pose.pose.orientation.w;

  	  	  desired_pose.absolute_position_tolerance.x = 0.05;
  	  	  desired_pose.absolute_position_tolerance.y = 0.05;
  	  	  desired_pose.absolute_position_tolerance.z = 0.01;

  	  	  desired_pose.absolute_roll_tolerance = 1;
  	  	  desired_pose.absolute_pitch_tolerance = 1;
  	  	  desired_pose.absolute_yaw_tolerance = 1;

  	  	  arm_navigation_msgs::addGoalConstraintToMoveArmGoal(desired_pose,goal);

  	  	  if (nh.ok())
  	  	  {
  	  	    bool finished_within_time2 = false;
  	  	    //SimpleCli= move_arm2.getState();
  	  	    move_arm2.sendGoal(goal);
  	  	    finished_within_time2 = move_arm2.waitForResult(ros::Duration(15.0));
  	  	    if (!finished_within_time2)
  	  	    {
  	  	    	move_arm2.cancelGoal();
  	  	      ROS_INFO("Timed out achieving goal A");
  	  	    }
  	  	    else
  	  	    {
  	  	      actionlib::SimpleClientGoalState state2 = move_arm2.getState();
  	  	      bool success2 = (state2 == actionlib::SimpleClientGoalState::SUCCEEDED);
  	  	      if(success2)
  	  	        ROS_INFO("Action finished: %s",state2.toString().c_str());
  	  	      else
  	  	        ROS_INFO("Action failed: %s",state2.toString().c_str());
  	  	    }
  	  	  }
  	  	  toSide = true;
    }

  void printPose(geometry_msgs::PoseStamped pose){
	  std::cout << "Wrist pose currently:" << std::endl;
	  std::cout << pose.pose.position.x << std::endl;
	  std::cout << pose.pose.position.y << std::endl;
	  std::cout << pose.pose.position.z << std::endl;
	  std::cout << pose.pose.orientation.x << std::endl;
	  std::cout << pose.pose.orientation.y << std::endl;
	  std::cout << pose.pose.orientation.z << std::endl;
	  std::cout << pose.pose.orientation.w << std::endl;
  }

  void place(tabletop_collision_map_processing::TabletopCollisionMapProcessing
  	        processing_call,int chosen,ros::NodeHandle nh,ros::ServiceClient collision_processing_srv,ros::ServiceClient object_detection_srv){


	   actionlib::SimpleActionClient<object_manipulation_msgs::PlaceAction>
	     place_client("/object_manipulator/object_manipulator_place", true);
	   while(!place_client.waitForServer(ros::Duration(2.0)) && nh.ok())
	     {
	       ROS_INFO_STREAM("Waiting for action client " << "/object_manipulator/object_manipulator_place");
	     }
	     if (!nh.ok()) exit(0);

	  geometry_msgs::PoseStamped place_location;
	  place_location.header.frame_id = processing_call.response.graspable_objects.at(0).reference_frame_id;
	  place_location.pose.orientation.w = 1;
	  place_location.header.stamp = ros::Time::now();
	  place_location.pose.position.x += 0.1;

	  ROS_INFO("Calling the place action");
	  object_manipulation_msgs::PlaceGoal place_goal;
	  place_goal.place_locations.push_back(place_location);
	  place_goal.collision_object_name = processing_call.response.collision_object_names.at(0);
	  place_goal.collision_support_surface_name = processing_call.response.collision_support_surface_name;

	    place_goal.grasp = pickupGrasp;
	    place_goal.arm_name = "right_arm";
	    place_goal.place_padding = 0.03;
	    place_goal.desired_retreat_distance = 0.1;
	    place_goal.min_retreat_distance = 0.05;

	    geometry_msgs::Vector3Stamped direction;
	    direction.header.stamp = ros::Time::now();
	    direction.header.frame_id = "base_link";
	    direction.vector.x = 0;
	    direction.vector.y = 0;
	    direction.vector.z = -1;
	    place_goal.approach.direction = direction;
	    place_goal.approach.desired_distance = 0.08;
	    place_goal.approach.min_distance = 0.06;
	    place_goal.use_reactive_place = false;
	    place_client.sendGoal(place_goal);

	    while (!place_client.waitForResult(ros::Duration(10.0)))
	    {
	      ROS_INFO("Waiting for the place action...");
	    }
	    object_manipulation_msgs::PlaceResult place_result =
	      *(place_client.getResult());
	    if (place_client.getState() !=
	        actionlib::SimpleClientGoalState::SUCCEEDED)
	    {
	      ROS_ERROR("Place failed with error code %d",
	                place_result.manipulation_result.value);
	    }
  }

  void pickup(tabletop_collision_map_processing::TabletopCollisionMapProcessing
	        processing_call,int chosen,ros::NodeHandle nh,ros::ServiceClient collision_processing_srv,ros::ServiceClient object_detection_srv){

	    actionlib::SimpleActionClient<object_manipulation_msgs::PickupAction>
	      pickup_client("/object_manipulator/object_manipulator_pickup", true);
	    while ( !ros::service::waitForService("/object_detection",ros::Duration(2.0)) && nh.ok() )
	    {
	      ROS_INFO("Waiting for object detection service to come up");
	    }
	    if (!nh.ok()) exit(0);
	    object_detection_srv =
	      nh.serviceClient<tabletop_object_detector::TabletopDetection>
	      ("/object_detection", true);

	    while ( !ros::service::waitForService("/tabletop_collision_map_processing/tabletop_collision_map_processing",
	                                          ros::Duration(2.0)) && nh.ok() )
	    {
	      ROS_INFO("Waiting for collision processing service to come up");
	    }
	    if (!nh.ok()) exit(0);
	    collision_processing_srv =
	      nh.serviceClient
	      <tabletop_collision_map_processing::TabletopCollisionMapProcessing>
	      ("/tabletop_collision_map_processing/tabletop_collision_map_processing", true);

	    while(!pickup_client.waitForServer(ros::Duration(2.0)) && nh.ok())
	    {
	      ROS_INFO_STREAM("Waiting for action client " << "/object_manipulator/object_manipulator_pickup");
	    }
	    if (!nh.ok()) exit(0);

	    ROS_INFO("Calling the pickup action");
	    object_manipulation_msgs::PickupGoal pickup_goal;
	    pickup_goal.target = processing_call.response.graspable_objects.at(chosen);
	    //pass the name that the object has in the collision environment
	    //this name was also returned by the collision map processor
	    pickup_goal.collision_object_name =
	      processing_call.response.collision_object_names.at(chosen);
	    pickup_goal.collision_support_surface_name =
	      processing_call.response.collision_support_surface_name;
	    pickup_goal.arm_name = "right_arm";
	    geometry_msgs::Vector3Stamped direction;
	    direction.header.stamp = ros::Time::now();
	    direction.header.frame_id = "base_link";
	    direction.vector.x = 0;
	    direction.vector.y = 0;
	    direction.vector.z = 1;
	    pickup_goal.lift.direction = direction;
	    pickup_goal.lift.desired_distance = 0.1;
	    pickup_goal.lift.min_distance = 0.05;
	    pickup_goal.use_reactive_lift = false;
	    pickup_goal.use_reactive_execution = false;
	    pickup_client.sendGoal(pickup_goal);
	    while (!pickup_client.waitForResult(ros::Duration(10.0)))
	    {
	      ROS_INFO("Waiting for the pickup action...");
	    }
	    object_manipulation_msgs::PickupResult pickup_result =
	      *(pickup_client.getResult());
	    if (pickup_client.getState() != actionlib::SimpleClientGoalState::SUCCEEDED)
	    {
	      ROS_ERROR("The pickup action has failed with result code %d",
	                pickup_result.manipulation_result.value);

	    }
	    pickupGrasp = pickup_result.grasp;
  }


//  desired_pose.pose.position.x = 0.2;
//  	  	  desired_pose.pose.position.y = 0.7;
//  	  	  desired_pose.pose.position.z = 0.2;

  void getPosition(ros::NodeHandle nh,std::string frame){
	  ros::ServiceClient get_state_client_ = nh.serviceClient<arm_navigation_msgs::GetRobotState>("/environment_server/get_robot_state");
	      arm_navigation_msgs::GetRobotState::Request req;
	      arm_navigation_msgs::GetRobotState::Response res;
	      get_state_client_.call(req,res);


	      ros::service::waitForService("pr2_right_arm_kinematics/get_fk");
	      ros::ServiceClient fk_client = nh.serviceClient<kinematics_msgs::GetPositionFK>("pr2_right_arm_kinematics/get_fk");

	      kinematics_msgs::GetPositionFK::Request  fk_request;
	      kinematics_msgs::GetPositionFK::Response fk_response;

	      fk_request.header.frame_id = frame;
	      fk_request.fk_link_names.resize(1);
	      fk_request.fk_link_names[0] = "r_wrist_roll_link";
	      fk_request.robot_state = res.robot_state;
	      if(fk_client.call(fk_request, fk_response))
	      		    {
	      			  std::cout << "OK" << std::endl;
	      			std::cout << fk_response.fk_link_names[0] << std::endl;
	      			std::cout << fk_response.pose_stamped[0].header.frame_id << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.position.x << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.position.y << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.position.z << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.orientation.x << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.orientation.y << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.orientation.z << std::endl;
	      			std::cout << fk_response.pose_stamped[0].pose.orientation.w << std::endl;
	      		    }
	      		  else{
	      			std::cout << "can't get link info" << std::endl;
	      		  }

  }

};

using namespace std;
using namespace json_prolog;
/*
namespace pr2_interactive_manipulation {
	typedef actionlib::SimpleActionClient<pr2_object_manipulation_msgs::IMGUIAction> Client;
}
*/
const std::string OBJECT_DETECTION_SERVICE_NAME = 
   	 "/object_detection";

void table_info(tabletop_object_detector::TabletopDetection detection_call,Prolog pl)
{
cout << "Table info" << endl;
cout << detection_call.response.detection.table.pose.header.frame_id << endl;
cout << detection_call.response.detection.table.pose.header.stamp << endl;
cout << detection_call.response.detection.table.pose.header.seq << endl;
cout << endl;

int nvert = detection_call.response.detection.table.convex_hull.vertices.size();
cout << "Number of table vertices: " << nvert;
cout << endl;
for (int v = 0 ; v < nvert ; v++) {
	cout << detection_call.response.detection.table.convex_hull.vertices[v].x << endl;
	cout << detection_call.response.detection.table.convex_hull.vertices[v].y << endl;
	cout << detection_call.response.detection.table.convex_hull.vertices[v].z << endl;

	cout << endl;
}
cout << endl;

cout << "Table position" << endl;
cout << detection_call.response.detection.table.pose.pose.position.x << endl;
float x = detection_call.response.detection.table.pose.pose.position.x;
cout << detection_call.response.detection.table.pose.pose.position.y << endl;
float y = detection_call.response.detection.table.pose.pose.position.y;
cout << detection_call.response.detection.table.pose.pose.position.z << endl;
float z = detection_call.response.detection.table.pose.pose.position.z;
cout << endl;

cout << "Table orientation" << endl;
cout << detection_call.response.detection.table.pose.pose.orientation.x << endl;
cout << detection_call.response.detection.table.pose.pose.orientation.y << endl;
cout << detection_call.response.detection.table.pose.pose.orientation.z << endl;
cout << detection_call.response.detection.table.pose.pose.orientation.w << endl;

float xmin1 = detection_call.response.detection.table.x_min;
float xmin2 = xmin1 + x;

float xmax1 =  detection_call.response.detection.table.x_max;
float xmax2 =xmax1 + x;

float ymin1 = detection_call.response.detection.table.y_min;
float ymin2 = ymin1 + y;

float ymax1 =  detection_call.response.detection.table.y_max;
float ymax2 = ymax1 + y;

float zmin2 = z - 0.02;
float zmax2 = z;


cout << "Table boundaries" << endl;
cout << xmin1 << endl;
cout << xmax1 << endl;
cout << ymin1 << endl;
cout << ymax1 << endl;

cout << endl;
cout << "Final boundaries:" << endl;
cout << xmin2 << endl;
cout << xmax2 << endl;
cout << ymin2 << endl;
cout << ymax2 << endl;
cout << zmin2 << endl;
cout << zmax2 << endl;


}

void clusterObsBBInit(tabletop_object_detector::TabletopDetection detection_call, int i, int npoints, json_prolog::Prolog pl)
{
	float xmin = std::numeric_limits<float>::max();
	float xmax =std::numeric_limits<float>::min();
	float ymin =std::numeric_limits<float>::max();
	float ymax =std::numeric_limits<float>::min();
	float zmin =std::numeric_limits<float>::max();
	float zmax =std::numeric_limits<float>::min();

	
		for (int j = 0 ; j < npoints ; j++) {
			if (detection_call.response.detection.clusters[i].points[j].x < xmin) {
				xmin = detection_call.response.detection.clusters[i].points[j].x;
			}
			if (detection_call.response.detection.clusters[i].points[j].x > xmax) {
				xmax = detection_call.response.detection.clusters[i].points[j].x;
			}
			if (detection_call.response.detection.clusters[i].points[j].y < ymin) {
				ymin = detection_call.response.detection.clusters[i].points[j].y;
			}
			if (detection_call.response.detection.clusters[i].points[j].y > ymax) {
				ymax = detection_call.response.detection.clusters[i].points[j].y;
			}
			if (detection_call.response.detection.clusters[i].points[j].z < zmin) {
				zmin = detection_call.response.detection.clusters[i].points[j].z;
			}
			if (detection_call.response.detection.clusters[i].points[j].z > zmax) {
				zmax = detection_call.response.detection.clusters[i].points[j].z;
			}

			//cout << detection_call.response.detection.clusters[i].points[j].x<< endl;
			//cout << detection_call.response.detection.clusters[i].points[j].y<< endl;
			//cout << detection_call.response.detection.clusters[i].points[j].z<< endl;
		}

		float xmid = (xmin + xmax) /2;
		float ymid = (ymin + ymax) /2;
		float zmid = (zmin + zmax) /2;

		string q = "locationObservationInit(";
		q += boost::lexical_cast<std::string>(i+1);
		q += ",[";
		q += boost::lexical_cast<std::string>(abs(xmin-xmax));
		q += ",";
		q += boost::lexical_cast<std::string>(abs(ymin-ymax));
		q += ",";
		q += boost::lexical_cast<std::string>(abs(zmin-zmax));
		q += "],[";
		q += boost::lexical_cast<std::string>(xmid);
		q += ",";
		q += boost::lexical_cast<std::string>(ymid);
		q += ",";
		q += boost::lexical_cast<std::string>(zmid);
		q += "])";

		cout << q << endl;
		//PrologBindings result = pl.once(q);
}

void clusterObsBBIteration(tabletop_object_detector::TabletopDetection detection_call, int i, int npoints, json_prolog::Prolog pl)
{
	float xmin = std::numeric_limits<float>::max();
	float xmax =std::numeric_limits<float>::min();
	float ymin =std::numeric_limits<float>::max();
	float ymax =std::numeric_limits<float>::min();
	float zmin =std::numeric_limits<float>::max();
	float zmax =std::numeric_limits<float>::min();


		for (int j = 0 ; j < npoints ; j++) {
			if (detection_call.response.detection.clusters[i].points[j].x < xmin) {
				xmin = detection_call.response.detection.clusters[i].points[j].x;
			}
			if (detection_call.response.detection.clusters[i].points[j].x > xmax) {
				xmax = detection_call.response.detection.clusters[i].points[j].x;
			}
			if (detection_call.response.detection.clusters[i].points[j].y < ymin) {
				ymin = detection_call.response.detection.clusters[i].points[j].y;
			}
			if (detection_call.response.detection.clusters[i].points[j].y > ymax) {
				ymax = detection_call.response.detection.clusters[i].points[j].y;
			}
			if (detection_call.response.detection.clusters[i].points[j].z < zmin) {
				zmin = detection_call.response.detection.clusters[i].points[j].z;
			}
			if (detection_call.response.detection.clusters[i].points[j].z > zmax) {
				zmax = detection_call.response.detection.clusters[i].points[j].z;
			}

			//cout << detection_call.response.detection.clusters[i].points[j].x<< endl;
			//cout << detection_call.response.detection.clusters[i].points[j].y<< endl;
			//cout << detection_call.response.detection.clusters[i].points[j].z<< endl;
		}

		float xmid = (xmin + xmax) /2;
		float ymid = (ymin + ymax) /2;
		float zmid = (zmin + zmax) /2;

		string q = "locationObservationIteration([";
		q += boost::lexical_cast<std::string>(xmin);
		q += ",";
		q += boost::lexical_cast<std::string>(xmax);
		q += ",";
		q += boost::lexical_cast<std::string>(ymin);
		q += ",";
		q += boost::lexical_cast<std::string>(ymax);
		q += ",";
		q += boost::lexical_cast<std::string>(zmin);
		q += ",";
		q += boost::lexical_cast<std::string>(zmax);
		q += "],[";
		q += boost::lexical_cast<std::string>(xmid);
		q += ",";
		q += boost::lexical_cast<std::string>(ymid);
		q += ",";
		q += boost::lexical_cast<std::string>(zmid);
		q += "])";

		cout << q << endl;
		//PrologBindings result = pl.once(q);
}


void objectsObservationsIteration(tabletop_object_detector::TabletopDetection detection_call, Prolog pl,ros::NodeHandle nh)
{
		while ( !ros::service::waitForService("/objects_database_node/get_model_description", ros::Duration(2.0)) && nh.ok() )
		{
			ROS_INFO("Waiting for service to come up");
		}

		int nclusters = detection_call.response.detection.clusters.size();
		string q = "nobjsObservationIteration(";
		q += boost::lexical_cast<std::string>(nclusters);
		q += ")";
		cout << q <<endl;
		//TODO query

		for (int i = 0 ; i < nclusters ; i++) {
			/*
			cout << "Cluster info, cluster " << i;
			cout << endl;
			cout << detection_call.response.detection.clusters[i].header.seq << endl;
			cout << detection_call.response.detection.clusters[i].header.stamp << endl;
			cout << detection_call.response.detection.clusters[i].header.frame_id << endl;
			*/
				int nchannels = detection_call.response.detection.clusters[i].channels.size();
				//cout << "Number of channels " << nchannels << endl;
				for (int k = 0 ; k < nchannels ; k++) {
					//cout << detection_call.response.detection.clusters[i].channels[k].name << endl;
				}

				for (int k = 0 ; k < nchannels ; k++) {
					//cout << "Channel " << k;
					//cout << endl;
					//cout << detection_call.response.detection.clusters[i].channels[k].values[0] << endl;
				}

				/*
				cout << "Points info" << endl;
				cout << "Number of points" << npoints << endl;
				*/
				int npoints = detection_call.response.detection.clusters[i].points.size();
				clusterObsBBIteration(detection_call, i, npoints, pl);
				//cout << detection_call.response.detection.cluster_model_indices[i] << endl;

				string q2 = "typeObservationIteration([";

								int nmodels2 = detection_call.response.detection.models[i].model_list.size();
								//cout << "Number of models for cluster: " << nmodels2;
								//cout << endl;
								for (int w = 0 ; w < nmodels2 ; w++) {
									//cout << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].model_id << endl;

									ros::ServiceClient househ_srv = nh.serviceClient<household_objects_database_msgs::GetModelDescription> ("/objects_database_node/get_model_description", true);
									household_objects_database_msgs::GetModelDescription model_desc;
									model_desc.request.model_id = detection_call.response.detection.models[i].model_list[w].model_id;
									househ_srv.call(model_desc);
									//cout << model_desc.response.return_code << endl;
									int ntags = model_desc.response.tags.size();
									if(w != 0){
										q2 += ",";
									}
									for (int s = 0 ; s < ntags ; s++) {
										//cout << model_desc.response.tags[s] << endl;
										if(s != 0){
											q2 += ",";
										}
										q2 += model_desc.response.tags[s];

									}
									//cout << model_desc.response.name << endl;
									//cout << model_desc.response.maker << endl;

									//cout << detection_call.response.detection.models[l].model_list[w].pose.header.seq << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.header.stamp << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.header.frame_id << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
									//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
									//cout << detection_call.response.detection.models[i].model_list[w].confidence << endl;
								}
								q2 += "])";
								cout << q2 << endl;
								//TODO query

			}

}

void scanTableIteration(tabletop_object_detector::TabletopDetection detection_call,Prolog pl,ros::NodeHandle nh)
{
	//table_info(detection_call, pl);
	objectsObservationsIteration(detection_call, pl,nh);
}

void objectsObservationsInit(tabletop_object_detector::TabletopDetection detection_call,Prolog pl,ros::NodeHandle nh){
	while ( !ros::service::waitForService("/objects_database_node/get_model_description", ros::Duration(2.0)) && nh.ok() )
	{
		ROS_INFO("Waiting for service to come up");
	}

	int nclusters = detection_call.response.detection.clusters.size();
	string q = "nobjsObservationInit(";
	q += boost::lexical_cast<std::string>(nclusters);
	q += ")";
	cout << q <<endl;
	//TODO query

	for (int i = 0 ; i < nclusters ; i++) {
		//cout << "Cluster info, cluster " << i;
		//cout << endl;
		//cout << detection_call.response.detection.clusters[i].header.seq << endl;
		//cout << detection_call.response.detection.clusters[i].header.stamp << endl;
		//cout << detection_call.response.detection.clusters[i].header.frame_id << endl;

			int nchannels = detection_call.response.detection.clusters[i].channels.size();
			//cout << "Number of channels " << nchannels << endl;
			for (int k = 0 ; k < nchannels ; k++) {
				//cout << detection_call.response.detection.clusters[i].channels[k].name << endl;
			}

			for (int k = 0 ; k < nchannels ; k++) {
				//cout << "Channel " << k;
				//cout << endl;
				//cout << detection_call.response.detection.clusters[i].channels[k].values[j] << endl;
			}

			//cout << "Points info" << endl;
			int npoints = detection_call.response.detection.clusters[i].points.size();
			//cout << "Number of points" << npoints << endl;

			clusterObsBBInit(detection_call, i, npoints, pl);
			//cout << detection_call.response.detection.cluster_model_indices[i] << endl;
		}

		int nmodels = detection_call.response.detection.models.size();
		cout << "Number of clusters: " << nmodels <<endl;
		for (int l = 0 ; l < nmodels ; l++) {

			string q2 = "typeObservationInit(";
			q2 += boost::lexical_cast<std::string>(l+1);
			q2 += ",[";


			int nmodels2 = detection_call.response.detection.models[l].model_list.size();
			cout << "Number of models for cluster: " << nmodels2;
			cout << endl;
			for (int w = 0 ; w < nmodels2 ; w++) {
				cout << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].model_id << endl;

				ros::ServiceClient househ_srv = nh.serviceClient<household_objects_database_msgs::GetModelDescription> ("/objects_database_node/get_model_description", true);
				household_objects_database_msgs::GetModelDescription model_desc;
				model_desc.request.model_id = detection_call.response.detection.models[l].model_list[w].model_id;
				househ_srv.call(model_desc);
				//cout << model_desc.response.return_code << endl;
				int ntags = model_desc.response.tags.size();
				if(w != 0){
					q2 += ",";
				}
				for (int s = 0 ; s < ntags ; s++) {
					cout << model_desc.response.tags[s] << endl;
					if(s != 0){
						q2 += ",";
					}
					q2 += model_desc.response.tags[s];

				}
				//cout << model_desc.response.name << endl;
				//cout << model_desc.response.maker << endl;

				//cout << detection_call.response.detection.models[l].model_list[w].pose.header.seq << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.header.stamp << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.header.frame_id << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.position << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
				//cout << detection_call.response.detection.models[l].model_list[w].pose.pose.orientation << endl;
				cout << detection_call.response.detection.models[l].model_list[w].confidence << endl;
			}
			q2 += "])";
			cout << q2 << endl;
			//TODO query
		}

}

void tableObservationsInit(tabletop_object_detector::TabletopDetection det){
	cout << "Table observations init." << endl;
	cout << det.response.detection.table.pose.header.frame_id << endl;
	cout << det.response.detection.table.pose.header.stamp << endl;
	cout << det.response.detection.table.pose.header.seq << endl;
	cout << endl;

	tf::TransformListener listener;
	geometry_msgs::PoseStamped pose = det.response.detection.table.pose;

	btScalar x = pose.pose.orientation.x;
	btScalar y = pose.pose.orientation.y;
	btScalar z = pose.pose.orientation.z;
	btScalar w = pose.pose.orientation.w;

	btScalar x2 = pose.pose.position.x;
	btScalar y2 = pose.pose.position.y;
	btScalar z2 = pose.pose.position.z;

	btTransform t1;
	t1.setOrigin(btVector3(x2,y2,z2));
	t1.setRotation(btQuaternion(x,y,z,w));
	btTransform t2 = t1.inverse();

	geometry_msgs::PoseStamped pose2;
	pose2.pose.position.x = t2.getOrigin().getX();
	pose2.pose.position.y = t2.getOrigin().getY();
	pose2.pose.position.z = t2.getOrigin().getZ();
	pose2.pose.orientation.x = t2.getRotation().getX();
	pose2.pose.orientation.y = t2.getRotation().getY();
	pose2.pose.orientation.z = t2.getRotation().getZ();
	pose2.pose.orientation.w = t2.getRotation().getW();

	cout << endl;
	cout << "Init pose" << endl;
	cout << pose.header.frame_id << endl;
	cout << pose.pose.position.x << endl;
	cout << pose.pose.position.y << endl;
	cout << pose.pose.position.z << endl;

	cout << endl;
	cout << "Transformed pose" << endl;
	cout << pose2.header.frame_id << endl;
	cout << pose2.pose.position.x << endl;
	cout << pose2.pose.position.y << endl;
	cout << pose2.pose.position.z << endl;

	int nvert = det.response.detection.table.convex_hull.vertices.size();
	cout << "Number of table vertices: " << nvert;
	cout << endl;
	for (int v = 0 ; v < 0 ; v++) {
		cout << det.response.detection.table.convex_hull.vertices[v].x << endl;
		cout << det.response.detection.table.convex_hull.vertices[v].y << endl;
		cout << det.response.detection.table.convex_hull.vertices[v].z << endl;

		cout << endl;
	}
	cout << endl;

	cout << "Table position" << endl;
	cout << det.response.detection.table.pose.pose.position.x << endl;
	cout << det.response.detection.table.pose.pose.position.y << endl;
	cout << det.response.detection.table.pose.pose.position.z << endl;
	cout << endl;

	cout << "Table orientation" << endl;
	cout << det.response.detection.table.pose.pose.orientation.x << endl;
	cout << det.response.detection.table.pose.pose.orientation.y << endl;
	cout << det.response.detection.table.pose.pose.orientation.z << endl;
	cout << det.response.detection.table.pose.pose.orientation.w << endl;

	btVector3 xmin1;
	xmin1.setX(det.response.detection.table.x_min);
	xmin1.setY(0);
	xmin1.setZ(0);
	btVector3 xmin2 = t1*xmin1;

	btVector3 xmax1;
	xmax1.setX(det.response.detection.table.x_max);
	xmax1.setY(0);
	xmax1.setZ(0);
	btVector3 xmax2 = t1*xmax1;

	btVector3 ymin1;
	ymin1.setX(0);
	ymin1.setY(det.response.detection.table.y_min);
	ymin1.setZ(0);
	btVector3 ymin2 = t1*ymin1;

	btVector3 ymax1;
	ymax1.setX(0);
	ymax1.setY(det.response.detection.table.y_max);
	ymax1.setZ(0);
	btVector3 ymax2 = t1*ymax1;

	btVector3 z1;
	z1.setX(0);
	z1.setY(0);
	z1.setZ(0);
	btVector3 ztransf = t1*z1;

	cout << endl;
	cout << "Table boundaries" << endl;
	cout << xmin1.getX() << endl;
	cout << xmax1.getX() << endl;
	cout << ymin1.getY() << endl;
	cout << ymax1.getY() << endl;

	cout << endl;
	cout << "Final boundaries:" << endl;
	cout << xmin2.getX() << endl;
	cout << xmax2.getX() << endl;
	cout << ymin2.getY() << endl;
	cout << ymax2.getY() << endl;
	cout << ztransf.getZ() - 0.2 << endl;
	cout << ztransf.getZ() << endl;

	float xmid = (xmin2.getX() + xmax2.getX()) /2;
	float ymid = (ymin2.getY() + ymax2.getY()) /2;
	float zmid = ((ztransf.getZ() - 0.2) + ztransf.getZ()) /2;

	string q = "tableObservation([";
	q += boost::lexical_cast<std::string>(abs(xmin2.getX()-xmax2.getX()));
	q += ",";
	q += boost::lexical_cast<std::string>(abs(ymin2.getY()-ymax2.getY()));
	q += ",";
	q += boost::lexical_cast<std::string>(abs((ztransf.getZ() - 0.2)-ztransf.getZ()));
	q += "],[";
	q += boost::lexical_cast<std::string>(xmid);
	q += ",";
	q += boost::lexical_cast<std::string>(ymid);
	q += ",";
	q += boost::lexical_cast<std::string>(zmid);
	q += "])";
	cout << q <<endl;
	//PrologBindings result = pl.once(q);
}

void scanTableInit(ros::ServiceClient object_detection_srv,ros::ServiceClient collision_processing_srv,Prolog pl,ros::NodeHandle nh){
	ROS_INFO("Scanning table for first time.");
	tabletop_object_detector::TabletopDetection detection_call;
	detection_call.request.return_clusters = true;
	detection_call.request.return_models = true;
	detection_call.request.num_models = 100;

	if (!object_detection_srv.call(detection_call))
	{
		ROS_ERROR("Scanning table for first time failed.");
	}
	if (detection_call.response.detection.result != detection_call.response.detection.SUCCESS)
	{
		ROS_ERROR("Scanning table for first time failed: Tabletop detection returned error code %d", detection_call.response.detection.result);
	}
    if (detection_call.response.detection.clusters.empty() && detection_call.response.detection.models.empty() )
    {
    	ROS_ERROR("Scanning table for first time failed: The tabletop detector detected the table, " "but found no objects");
	}

    tableObservationsInit(detection_call);
    objectsObservationsInit(detection_call,pl,nh);

	ROS_INFO("Calling collision map processing");
	tabletop_collision_map_processing::TabletopCollisionMapProcessing processing_call;
	processing_call.request.detection_result = detection_call.response.detection;
	processing_call.request.reset_collision_models = true;
	processing_call.request.reset_attached_models = true;
	processing_call.request.desired_frame = "base_link";

	if (!collision_processing_srv.call(processing_call))
	{
		ROS_ERROR("Collision map processing service failed");
	}
	if (processing_call.response.graspable_objects.empty())
	{
		ROS_ERROR("Collision map processing returned no graspable objects");
	}
}


int main(int argc, char **argv)
{
 	ros::init(argc, argv, "pick_and_place_app");
  	ros::NodeHandle nh;

  	Prolog pl;
  	/*
  	string q = "scenario11";
  	PrologQueryProxy bdgs = pl.query(q);
	*/
  	ros::ServiceClient object_detection_srv;
    ros::ServiceClient collision_processing_srv;

    while ( !ros::service::waitForService("/object_detection", ros::Duration(10.0)) && nh.ok() )
  	{
    	ROS_INFO("Waiting for object detection service to come up");
  	}
  	if (!nh.ok()) exit(0);
  	object_detection_srv = nh.serviceClient<tabletop_object_detector::TabletopDetection>("/object_detection", true);

  	while ( !ros::service::waitForService("/tabletop_collision_map_processing/tabletop_collision_map_processing",ros::Duration(10.0)) && nh.ok() )
  	{
  		ROS_INFO("Waiting for collision processing service to come up");
  	}
  	if (!nh.ok()) exit(0);
  	collision_processing_srv = nh.serviceClient<tabletop_collision_map_processing::TabletopCollisionMapProcessing>("/tabletop_collision_map_processing/tabletop_collision_map_processing", true);

  	LeftArm left;
  	left.moveSide(nh);
  	left.getPosition(nh,"base_link");

  	RightArm right;
  	right.moveSide(nh);

	RobotHead head;
	//head.shakeHead(3);
	head.lookdown();

  	collision_processing_srv = nh.serviceClient<tabletop_collision_map_processing::TabletopCollisionMapProcessing> ("/tabletop_collision_map_processing/tabletop_collision_map_processing", true);

  	scanTableInit(object_detection_srv,collision_processing_srv,pl,nh);

  	//left.getPosition(nh);
  			tabletop_collision_map_processing::TabletopCollisionMapProcessing
  				        processing_call = head.scanTable(nh,collision_processing_srv,object_detection_srv);

  			left.pickup(processing_call,0,nh,collision_processing_srv,object_detection_srv);
  			geometry_msgs::PoseStamped start_pose = left.getPosition(nh,"base_link");
  			left.setPickupLocation(start_pose);
  			left.setOrientation(start_pose);
  			left.moveSide(nh,0,0,0,1);

  			double x = left.pickup_location.getX();
  			double y = left.pickup_location.getY();
  			double z = left.pickup_location.getZ();
  			cout << x << endl;
  			cout << y << endl;
  			cout << z << endl;
  			left.moveToLocation(nh,x,y,z);
  			//left.moveToLocation(nh,0.66,0.1,0.8);

  	bool end = false;
  	while(end == false){
  		string input;
  		cout << "What do you want to do?" << endl;
  		cin >> input;
  		//cout << input;

  		if (input=="scan")
  		{
  			cout << "Scanning table iteration started." << endl;
		  	tabletop_object_detector::TabletopDetection detection_call;
		  	detection_call.request.return_clusters = true;
		  	detection_call.request.return_models = true;
		  	detection_call.request.num_models = 1;
		  	if (!object_detection_srv.call(detection_call))
		  	{
		    		ROS_ERROR("Tabletop detection service failed");
		    		return -1;
		  	}
		  	if (detection_call.response.detection.result != detection_call.response.detection.SUCCESS)
		  	{
		    		ROS_ERROR("Tabletop detection returned error code %d",detection_call.response.detection.result);
		   		 return -1;
		  	}
		  	if (detection_call.response.detection.clusters.empty() && detection_call.response.detection.models.empty() )
		  	{
		    		ROS_ERROR("The tabletop detector detected the table, "
		              "but found no objects");
		    		return -1;
		  	}

			scanTableIteration( detection_call,pl,nh);
	}
	else if (input == "pickup")
	{
		//left.getPosition(nh);
		tabletop_collision_map_processing::TabletopCollisionMapProcessing
			        processing_call = head.scanTable(nh,collision_processing_srv,object_detection_srv);

		left.pickup(processing_call,0,nh,collision_processing_srv,object_detection_srv);
		geometry_msgs::PoseStamped start_pose = left.getPosition(nh,"base_link");
		left.setPickupLocation(start_pose);
		left.setOrientation(start_pose);
		left.moveSide(nh,0,0,0,1);
	}
	else if(input == "place")
	{
		//left.getPosition(nh);

		double x = left.pickup_location.getX();
		double y = left.pickup_location.getY();
		double z = left.pickup_location.getZ();
		cout << x << endl;
		cout << y << endl;
		cout << z << endl;
		left.moveToLocation(nh,x,y,z);
		//left.place(processing_call,0,nh,collision_processing_srv,object_detection_srv);
		//left.getPosition(nh);
	}
	else if (input == "leftside"){
		left.moveSideStandard(nh);
	}
	else if (input == "leftside2"){
		geometry_msgs::PoseStamped start_pose = left.getPosition(nh,"base_link");
		 double magnitude = sqrt(pow(start_pose.pose.orientation.x,2.0) + pow(start_pose.pose.orientation.y,2.0) + pow(start_pose.pose.orientation.z,2.0) + pow(start_pose.pose.orientation.w,2.0));
			  double w = start_pose.pose.orientation.w / magnitude;
			  double x = start_pose.pose.orientation.x /  magnitude;
			  double y = start_pose.pose.orientation.y / magnitude;
			  double z = start_pose.pose.orientation.z / magnitude;
			  cout << x << endl;
			  		cout << y << endl;
			  		cout << z << endl;
			  		cout << w << endl;
			  left.moveSide(nh,x,y,z,w);
	}

	else if (input == "rightside"){
			right.moveSide(nh);
		}

	else if (input=="end")
	{ 
		cout << "Closing program";
		end = true;
	}
	else
	{
		cout << "Command does not exist";
	}
  }

	
	return 0;
}



